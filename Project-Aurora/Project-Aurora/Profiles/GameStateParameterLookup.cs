using System;
using System.Collections.Generic;
using System.Linq;
using AuroraRgb.Nodes;
using AuroraRgb.Utils;
using FastMember;

namespace AuroraRgb.Profiles;

/// <summary>
/// Data structure that holds a record of all game state parameters for a particular type of GameState.
/// </summary>
public sealed class GameStateParameterLookup
{
    // Internal parameter store. Key = full path, Value = meta
    private readonly Dictionary<string, GameStateParameterLookupEntry> _lookup = new();

    /// <summary>
    /// Creates a new <see cref="GameStateParameterLookup"/> by inspecting all properties on the given type.
    /// </summary>
    public GameStateParameterLookup(Type type)
    {
        // use NodePropertyLookups generated by the AuroraSourceGenerator to populate the lookup
        if (NodePropertyLookups.PropertyMap.TryGetValue(type, out var propertyLookups))
        {
            foreach (var lookup in propertyLookups)
            {
                if (lookup.IsFolder)
                {
                    _lookup[lookup.GsiPath] = GameStateParameterLookupEntry.Folder(lookup.Name, lookup.GsiPath, lookup.Description ?? string.Empty);
                }
                else
                {
                    if (GSIPropertyTypeConverter.TypeToPropertyType(lookup.Type) != GSIPropertyType.None)
                        _lookup[lookup.GsiPath] = GameStateParameterLookupEntry.Property(lookup.Name, lookup.GsiPath, lookup.Type);
                }
            }

            return;
        }

        OldLookupFill(type);
    }

    private void OldLookupFill(Type rootType)
    {
        var typeCache = new Dictionary<Type, TypeAccessor>();

        void Visit(string path, string name, Type type)
        {
            // If this is a variable that can be handled (such as a number or bool), add it to the lookup
            if (GSIPropertyTypeConverter.TypeToPropertyType(type) != GSIPropertyType.None)
                _lookup.Add(path, GameStateParameterLookupEntry.Property(name, path, type));

            else if (type.Namespace.Contains("AuroraRgb."))
            {
                // Else if this not a handlable property, check if it's a node or list of nodes and if so make a folder and visit it's children
                if (path != "") // If it's the root folder, don't add it
                    _lookup.Add(path, GameStateParameterLookupEntry.Folder(name, path, string.Empty));

                if (!typeCache.TryGetValue(type, out var accessor))
                {
                    accessor = TypeAccessor.Create(type);
                    typeCache[type] = accessor;
                }

                if (!accessor.GetMembersSupported) return;
                foreach (var member in accessor.GetMembers())
                {
                    if (member.Type == type) continue; // Ignore recursive types
                    if (member.GetAttribute(typeof(GameStateIgnoreAttribute), true) != null) continue; // Ignore properties with [GameStateIgnore]

                    var nextPath = (path + '/' + member.Name).TrimStart('/');

                    // If the type is an Enumerable with a range attribute, visit for each item in that range
                    if (member.Type.GetGenericInterfaceTypes(typeof(IEnumerable<>)) is { } ienumTypes && typeof(Node).IsAssignableFrom(ienumTypes[0]) &&
                        member.GetAttribute(typeof(RangeAttribute), true) is RangeAttribute range)
                        for (var i = range.Start; i <= range.End; i++)
                            Visit(nextPath + '/' + i, i.ToString(), ienumTypes[0]);

                    // Recursively visit the next type (do this even if it is IEnumerable, as it might be a custom class that implements IEnumerable with extra properties)
                    Visit(nextPath, member.Name, member.Type);
                }
            }
        }

        // Start the recursive function at the root.
        Visit("", "", rootType);
    }

    /// <summary>
    /// Attempts to get the definition for the folder or property at the given path.
    /// </summary>
    public GameStateParameterLookupEntry this[string path] => _lookup[path];

    /// <summary>
    /// Gets all the direct/first-level children of the folder at the given path.<br/>
    /// Optionally, only children ones that either are of the given type (in the case of properties) or that contain atleast one property of the given type (in the case of folders).
    /// </summary>
    /// <param name="path">Only children that are within the folder at the given path will be returned.</param>
    /// <param name="type">If not <see cref="GSIPropertyType.None"/>, only children of this type and only folders that contain atleast one property of this type will be returned.</param>
    public IEnumerable<GameStateParameterLookupEntry> Children(string path = "", GSIPropertyType type = GSIPropertyType.None) =>
        from kvp in _lookup
        where GetFolderOf(kvp.Key) == path // only include anything in this folder
        where type == GSIPropertyType.None // if type is none, don't worry about type filtering
              || (kvp.Value.IsFolder && AllChildren(kvp.Key).Any(c => c.Type == type)) // return a folder if it contains atleast one child of type
              || (!kvp.Value.IsFolder && kvp.Value.Type == type) // return a property if it is of type
        select kvp.Value;

    /// <summary>Returns a list of all children of the given path, REGARDLESS of depth.</summary>
    private IEnumerable<GameStateParameterLookupEntry> AllChildren(string path)
    {
        if (!path.EndsWith('/')) path += '/';
        return from kvp in _lookup where kvp.Key.StartsWith(path) select kvp.Value;
    }

    public bool IsValidParameter(string path, GSIPropertyType type = GSIPropertyType.None) =>
        _lookup.TryGetValue(path, out var entry) && !entry.IsFolder && (type == GSIPropertyType.None || entry.Type == type);

    /// <summary>
    /// Returns the folder that the given path is in.
    /// </summary>
    private static string GetFolderOf(string path) => path.Contains('/') ? path[..path.LastIndexOf('/')] : "";
}

/// <summary>
/// Plain object that holds metadata about a single parameter or folder in the <see cref="GameStateParameterLookup"/> collection.
/// </summary>
public sealed class GameStateParameterLookupEntry
{
    public required string Name { get; init; }
    public required string Path { get; init; }
    public required bool IsFolder { get; init; }
    public required Type? ClrType { get; init; }
    public required GSIPropertyType Type { get; init; }
    public required string Description { get; init; }

    public string DisplayName => Name.CamelCaseToSpaceCase();

    internal static GameStateParameterLookupEntry Folder(string name, string path, string description) => new()
    {
        Name = name,
        Path = path,
        IsFolder = true,
        ClrType = null,
        Type = GSIPropertyType.None,
        Description = description,
    };

    internal static GameStateParameterLookupEntry Property(string name, string path, Type? type) => new()
    {
        Name = name,
        Path = path,
        IsFolder = false,
        ClrType = type,
        Type = GSIPropertyTypeConverter.TypeToPropertyType(type),
        Description = string.Empty,
    };
}